**<p align="right">Node.js Unleashed: Full-Stack Server Solutions That Shine</p>**

[[Start]](../Introduction.md) → **[ Node Fundamentals ]** → [[Express Mastery]](#express) → [[MongoDB Power]](#mongodb) → [[YourDreamProject LIVE]](#project)

## Node.js Fundamentals
* [What is Node.js and why use it?](1-1.md)
* [Event-driven, non-blocking I/O, and single-threaded model](1-2.md)
* [Modules, npm (Node Package Manager)](#Modules-npm-Node-Package-Manager)
* Basic HTTP server

### Modules, npm (Node Package Manager)

In Node.js, **modules** are like building blocks that help you organize and reuse code efficiently. Imagine you’re still that chef in the restaurant. Instead of preparing every ingredient from scratch for every dish, you have pre-made sauces, chopped veggies, or spice mixes ready to go. Modules are those pre-made pieces—self-contained chunks of code you can pull into your project whenever you need them. It allows you to organize your code into smaller, manageable pieces, making it more maintainable and easier to debug.

Node.js uses a module system based on the **CommonJS** standard. Every file in Node.js is treated as a module by default, and you can export functionality from one file and import it into another. This keeps your codebase modular, clean, and easy to maintain. Here’s how it works:
- **Exporting**: In a file, you decide what functionality (functions, objects, etc.) you want to share with other parts of your app using `module.exports` or `exports`.
- **Importing**: In another file, you bring in that functionality using the `require()` function.

Node.js comes with a set of **built-in modules** that you can use right out of the box. These modules handle a variety of common tasks like file manipulation, networking, and more. Some of the most commonly used core modules include:
- **fs**: Handles file system operations like reading and writing files.
- **http**: Allows you to create an HTTP server to handle web requests.
- **path**: Provides utilities for working with file and directory paths.
- **url**: Helps with parsing and formatting URLs.

To use a core module, you simply **require** it in your code. For example, to read a file using the **fs** module, you would write:
```javascript
const fs = require('fs');

fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});
```
In addition to the built-in modules, you can also create your own custom modules to encapsulate functionality. This modularity ties into Node.js’s efficiency. Since it’s event-driven and non-blocking, you can create small, focused modules that handle specific tasks—like responding to a user request or reading a file—without clogging up the single-threaded event loop. For instance, you might have a module that handles database queries asynchronously, letting the event loop keep spinning while the query runs.

For example, let’s say you have a file called `car.js`:
```javascript
// car.js
function driveCar(speed) {
  return `Drive with ${speed}`;
}

module.exports = { driveCar };
```
Then, in your main `app.js` file, you can use it:
```javascript
// app.js
const { driveCar } = require('./car.js');
console.log(driveCar('80 km/hour')); 
```
**npm (Node Package Manager)**

When working with Node.js, you'll often need external libraries or packages to speed up your development process. **npm (Node Package Manager)** is the default package manager for Node.js, and it allows you to easily install, manage, and share packages. What is npm?

npm is a command-line tool that comes bundled with Node.js. It connects to an online registry of open-source packages that you can install and use in your application. You can think of npm as the "app store" for Node.js libraries.

**Key npm Concepts:**
1. **Installing Packages**:
To use an npm package, you first need to install it. For example, if you want to use the popular **express** package (a web framework for Node.js), you would run the following command:
```bash
npm install express
```
This command downloads and installs the package into a folder called `node_modules`, which is where all your project’s dependencies are stored.

2. **package.json**:
This is the heart of any Node.js project. It’s a file that tracks project’s metadata, dependencies, and scripts. You can generate it by running:
```bash
npm init
```
This command will guide you through setting up the `package.json` file with basic information about your project. It also stores the dependencies you've installed, so anyone else working on the project can easily install the same dependencies using:
```bash
npm install
```
The `package.json` file will automatically update with the installed packages. Here’s an example of a simple `package.json` file:
```json
{
  "name": "my-node-app",
  "version": "1.0.0",
  "main": "index.js",
  "dependencies": {
    "express": "^4.17.1"
  },
  "devDependencies": {},
  "scripts": {
    "start": "node index.js"
  }
}
```
3. **Using Packages**:
   Once installed, you `require()` the package like any module. Example with Express:
     ```javascript
     const express = require('express');
     const app = express();

     app.get('/', (req, res) => {
       res.send('Welcome to my restaurant!');
     });

     app.listen(3000, () => {
       console.log('Server running on port 3000');
     });
     ```
4. **Global Packages**:
   Some tools can be installed globally with `npm install -g <package-name>`.

[Memory Boost](1-2MB.md)
