**<p align="right">Node.js Unleashed: Full-Stack Server Solutions That Shine</p>**

[[Start]](../Introduction.md) → **[ Node Fundamentals ]** → [[Express Mastery]](#express) → [[MongoDB Power]](#mongodb) → [[YourDreamProject LIVE]](#project)

## Node.js Fundamentals
* [What is Node.js and why use it?](1-1.md)
* [Event-driven, non-blocking I/O, and single-threaded model](1-2.md)
* [Modules, npm (Node Package Manager)](#Modules-npm-Node-Package-Manager)
* Basic HTTP server

### Modules, npm (Node Package Manager)

In Node.js, **modules** are like building blocks that help you organize and reuse code efficiently. Imagine you’re still that chef in the restaurant. Instead of preparing every ingredient from scratch for every dish, you have pre-made sauces, chopped veggies, or spice mixes ready to go. Modules are those pre-made pieces—self-contained chunks of code you can pull into your project whenever you need them. It allows you to organize your code into smaller, manageable pieces, making it more maintainable and easier to debug.

Node.js uses a module system based on the **CommonJS** standard. Every file in Node.js is treated as a module by default, and you can export functionality from one file and import it into another. This keeps your codebase modular, clean, and easy to maintain. Here’s how it works:
- **Exporting**: In a file, you decide what functionality (functions, objects, etc.) you want to share with other parts of your app using `module.exports` or `exports`.
- **Importing**: In another file, you bring in that functionality using the `require()` function.

Node.js comes with a set of **built-in modules** that you can use right out of the box. These modules handle a variety of common tasks like file manipulation, networking, and more. Some of the most commonly used core modules include:
- **fs**: Handles file system operations like reading and writing files.
- **http**: Allows you to create an HTTP server to handle web requests.
- **path**: Provides utilities for working with file and directory paths.
- **url**: Helps with parsing and formatting URLs.

To use a core module, you simply **require** it in your code. For example, to read a file using the **fs** module, you would write:
```javascript
const fs = require('fs');

fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});
```


For example, let’s say you have a file called `car.js`:
```javascript
// car.js
function driveCar(speed) {
  return `Drive with ${speed}`;
}

module.exports = { driveCar };
```
Then, in your main `app.js` file, you can use it:
```javascript
// app.js
const { driveCar } = require('./car.js');
console.log(driveCar('80 km/hour')); 
```

This modularity ties into Node.js’s efficiency. Since it’s event-driven and non-blocking, you can create small, focused modules that handle specific tasks—like responding to a user request or reading a file—without clogging up the single-threaded event loop. For instance, you might have a module that handles database queries asynchronously, letting the event loop keep spinning while the query runs.

[Memory Boost](1-2MB.md)
