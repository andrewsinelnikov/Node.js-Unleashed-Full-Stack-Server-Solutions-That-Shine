**<p align="right">Node.js Unleashed: Full-Stack Server Solutions That Shine</p>**

[[Start]](../Introduction.md) → **[ Node Fundamentals ]** → [[Express Mastery]](#express) → [[MongoDB Power]](#mongodb) → [[YourDreamProject LIVE]](#project)

## Node.js Fundamentals
* [What is Node.js and why use it?](1-1.md)
* [Event-driven, non-blocking I/O, and single-threaded model](#Event-driven-non-blocking-IO-and-single-threaded-model)
* Modules, npm (Node Package Manager)
* Basic HTTP server

### Event-driven, non-blocking I/O, and single-threaded model

To understand why Node.js is so powerful, you need to get familiar with the concepts that make it tick. The way Node.js handles requests, processes tasks, and manages multiple users all comes down to three core principles: event-driven, non-blocking I/O, and single-threaded. 

**Event-driven**

Imagine a chef in a restaurant juggling multiple orders at once. Instead of standing still and waiting for one dish to be cooked before starting another, the chef quickly moves from one task to another as each order reaches a milestone (e.g., the steak is sizzling, the salad is tossed). Node.js works in a similar way.

Node.js operates on an "event-driven" system. Instead of running code line-by-line and waiting for each task to finish, it listens for specific events (like a user clicking something or a file being read) and responds when they happen. When you make a request to the server, Node.js triggers an event. The server doesn’t sit idly waiting for a response but continues handling other tasks until the event (like a database query or file read) completes. When the event is done, Node.js picks it up and processes the result. For example, when a user visits your site (an event), Node.js triggers a function to send them the homepage. It stays active and ready for the next user instead of pausing. This approach makes Node.js extremely efficient in handling concurrent requests.

**Non-blocking I/O**

I/O (Input/Output) operations are the activities that involve interacting with external resources, such as reading from a file, accessing a database, fetching data from an API, or making an HTTP request. In traditional programming environments, I/O operations can block the entire process, meaning that the system can’t do anything else until the I/O task is completed.

In contrast, Node.js uses non-blocking I/O, meaning that when it requests I/O, it doesn’t pause to wait for the operation to finish. Instead, it continues processing other tasks and only comes back to the I/O operation once it's complete. This allows Node.js to handle many operations concurrently without getting bogged down by waiting on slow processes like database queries or file system access.

[Memory Boost](1-2MB.md)

