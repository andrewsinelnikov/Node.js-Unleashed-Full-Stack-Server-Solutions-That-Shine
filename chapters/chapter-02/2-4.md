**<p align="right">Node.js Unleashed: Full-Stack Server Solutions That Shine</p>**

[[Start]](../Introduction.md) → [[ Node Fundamentals ]](../chapter-01/1-1.md) → **[Express Mastery]** → [[MongoDB Power]](../chapter-03/3-1.md) → [[Secure, Smart & Scalable]](../chapter-04/4-1.md) → [[YourDreamProject LIVE]](../chapter-05/5-1.md)

# Express Mastery
* [Express.js: what, why, and how to set it up](2-1.md)
* [Routing, middleware, structure](2-2.md)
* [Request and response deep dive](2-3.md)
* **In-memory CRUD & RESTful API Design**
* [Logging, error handling basics](2-5.md)
* [Environment Configuration](2-6.md)
* [Mini-Projects](2-7.md)
* [Portfolio Project](2-8.md)

## In-memory CRUD & RESTful API Design

Now that you’ve mastered Express fundamentals like routing, middleware, and handling requests/responses, it’s time to build something real: a **RESTful API** that performs **CRUD operations (Create, Read, Update, Delete)** on in-memory data. In this section, you’ll learn how to apply REST principles to build clean, predictable APIs — no database required (yet).

### What is CRUD?

CRUD represents the four basic operations you can perform on data:

| Operation | HTTP Method | Description             |
| --------- | ----------- | ----------------------- |
| Create    | POST        | Add a new resource      |
| Read      | GET         | Retrieve one or many    |
| Update    | PUT / PATCH | Modify an existing item |
| Delete    | DELETE      | Remove a resource       |

---
### RESTful API Design Principles

A **RESTful API** (REpresentational State Transfer) follows conventions for structuring routes and handling requests to create scalable, stateless, and client-server APIs. REST uses standard HTTP methods (GET, POST, PUT, DELETE) to perform operations on resources, identified by URLs. Let’s break down the key ideas:

- *Stateless*: Each request contains all the information needed to process it. The server doesn’t store client state between requests.
- *Client-Server*: The client (e.g., a browser) and server (Express app) are separate, communicating via HTTP.
- *Uniform Interface*: REST APIs use standard HTTP methods and consistent URL patterns (e.g., `/users` for a collection, `/users/:id` for a specific resource).
- *Resource-Based*: Resources (e.g., users, products) are represented as nouns in URLs, manipulated using HTTP methods.
- *Hypermedia (Optional)*: APIs can include links to related resources (e.g., `{ "user": { "id": 1, "links": { "self": "/users/1" } } }`). This is less common in basic APIs.

**RESTful APIs map HTTP methods to CRUD operations**

- *GET*: Retrieve a resource or list of resources (e.g., `GET /users` or `GET /users/1`).
- *POST*: Create a new resource (e.g., `POST /users`).
- *PUT*: Update an existing resource (e.g., `PUT /users/1`). Typically replaces the entire resource.
- *DELETE*: Remove a resource (e.g., `DELETE /users/1`).
- *PATCH* (optional): Partially update a resource. Not used in this section but common in advanced APIs.

**Status Codes Matter**

| Status Code      | Meaning                                                         |
| ---------------- | --------------------------------------------------------------- |
| 200 OK           | Successful request (e.g., GET or PUT)                           |
| 201 Created      | Resource created (e.g., POST)                                   |
| 204 No Content   | Request succeeded, no response body (sometimes used for DELETE) |
| 400 Bad Request  | Invalid request data (e.g., missing or invalid fields)          |
| 404 Not Found    | Resource doesn’t exist                                          |
| 500 Server Error | Server-side error                                               |

---

### Putting It All Together
Here’s an example combining the concepts above:
```javascript
  const express = require('express');
  const cookieParser = require('cookie-parser');
  const path = require('path');
  
  const app = express();
  
  // Middleware
  app.use(express.json());
  app.use(express.urlencoded({ extended: true }));
  app.use(cookieParser());
  app.use(express.static('public'));
  
  // Routes
  app.get('/', (req, res) => {
    res.send('<h1>Home Page</h1>');
  });
  
  app.post('/api/users', (req, res) => {
    const user = req.body;
    res.status(201).json({ created: user });
  });
  
  app.get('/set-cookie', (req, res) => {
    res.cookie('session', 'abc123', { maxAge: 900000 });
    res.send('Cookie set!');
  });
  
  app.get('/file', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'example.pdf'));
  });
  
  app.get('/redirect', (req, res) => {
    res.redirect('/new-page');
  });
  
  app.get('/new-page', (req, res) => {
    res.json({ message: 'Redirected here' });
  });
  
  // Error Handling
  app.use((req, res) => {
    res.status(404).json({ error: 'Route not found' });
  });
  
  app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Internal server error' });
  });
  
  // Start Server
  const port = 3000;
  app.listen(port, () => {
    console.log(`Server running on http://localhost:${port}`);
  });
```
   
### What’s Next?

You’ve now mastered the `req` and `res` objects, handling various data formats, and sending different types of responses. In the next section, you’ll build a simple in-memory CRUD API. No database yet—just arrays and objects to simulate one. You’ll create routes for adding, reading, updating, and deleting; move logic into controllers; practice basic input validation and error handling. This sets the foundation for building real APIs before connecting to a database in future chapters.

[Memory Boost](2-4MB.md)

