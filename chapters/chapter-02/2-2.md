**<p align="right">Node.js Unleashed: Full-Stack Server Solutions That Shine</p>**

[[Start]](../Introduction.md) → [[ Node Fundamentals ]](../chapter-01/1-1.md) → **[Express Mastery]** → [[MongoDB Power]](../chapter-03/3-1.md) → [[Secure, Smart & Scalable]](../chapter-04/4-1.md) → [[YourDreamProject LIVE]](../chapter-05/5-1.md)

# Express Mastery
* [Express.js: what, why, and how to set it up](2-1.md)
* **Routing, middleware, structure**
* [Request and response deep dive](2-3.md)
* [In-memory CRUD](2-4.md)
* [Logging, error handling basics](2-5.md)
* [Environment Configuration](2-6.md)
* [Mini-Projects](2-7.md)
* [Portfolio Project](2-8.md)

## Routing, middleware, structure

Once you’ve got a basic Express server up and running, it’s time to level up. This section dives into middleware, routing, and structuring your project for growth — critical concepts for creating scalable, maintainable, and robust full-stack applications.

### What is Middleware?

In Express, middleware is any function that has access to the request (`req`), response (`res`), and the next middleware (`next`) in the application's request-response cycle. Middleware can execute code (e.g., logging, authentication), modify the `req` or `res` objects, end the request-response cycle (e.g., send a response), call the next middleware or route handler using `next()`.

Middleware is executed in the order it’s defined, forming a pipeline for processing requests. You can think of middleware as a series of filters or steps a request passes through before reaching a route handler or sending a response.

**Types of Middleware**
1. *Application-level middleware* - applied globally or to specific paths using `app.use()` or `app.METHOD()`.
2. *Router-level middleware* - applied to specific routes or route groups using `router.use()`.
3. *Built-in middleware* - provided by Express (e.g., `express.json()`).
4. *Third-party middleware* - external libraries (e.g., `morgan`, `helmet`).
5. *Error-handling middleware* - special middleware with four parameters to handle errors.

### Built-in Middleware

Express includes a few essential middleware functions:
- `express.json()` - parses incoming requests with JSON payloads and  req.body will automatically contain parsed JSON for POST/PUT requests.
  ```javascript
  app.use(express.json());
  ```
- `express.static()` - serves static files (e.g., HTML, CSS, images) from a specified directory. Commonly used in full-stack apps to serve a frontend build (e.g., a React or Vue app).
  ```javascript
  app.use(express.static('public'));
  ```
  Any file in the `/public` folder is now served at `http://localhost:3000/filename.ext`.

### Custom Middleware

You can write your own middleware for custom needs.  Let’s explore three common use cases: logging, error handling, and authentication.
- *Logging Middleware* - logs details about each request (e.g., method, URL, timestamp)
  ```javascript
    const logger = (req, res, next) => {
      console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
      next();
    };

    app.use(logger);
  ```
- *Error Handling Middleware* - handles errors thrown in your app. Error middleware has four arguments: (err, req, res, next):
  ```javascript
      app.use((err, req, res, next) => {
        console.error(err.stack);
        res.status(500).json({ error: 'Something broke!' });
      });
  ```
- *Authentication Middleware* - checks if a request is authenticated (e.g., by validating a token)
  ```javascript
      const authMiddleware = (req, res, next) => {
        if (req.headers.authorization === 'secret-token') {
          next();
        } else {
          res.status(401).json({ error: 'Unauthorized' });
        }
      };
  ```
  Apply to specific routes
  ```javascript
      app.get('/protected', authMiddleware, (req, res) => {
        res.send('Protected content');
      });
  ```
  In a real app, use a library like jsonwebtoken for proper token validation.

### Third-Party Middleware

Third-party middleware extends Express with additional functionality. Install these using npm and integrate them with `app.use()`. Here are three popular ones:
- `morgan` - a robust logging middleware that generates detailed request logs
   ```bash
      npm install morgan
   ```
   Usage:
   ```javascript
      const morgan = require('morgan');
      app.use(morgan('dev')); // Logs requests in 'dev' format
   ```
- `helmet` - adds security headers to protect your app from common vulnerabilities (e.g., XSS, clickjacking)
   ```bash
      npm install helmet
   ```
   Usage:
   ```javascript
      const helmet = require('helmet');
      app.use(helmet());
   ```
- `cors` (Cross-Origin Resource Sharing) - nables CORS, allowing your API to be accessed from different domains (e.g., a    frontend on `http://localhost:3000` calling an API on `http://localhost:5000`)
   ```bash
      npm install cors
   ```
   Usage:
   ```javascript
      const cors = require('cors');
      app.use(cors());
   ```

### What’s Next?

You’ve set up a basic Express server, learned why it’s better than raw Node.js, compared it to other frameworks, and organized your project for scalability. In the next section, we’ll dive into **Routing, Middleware, and Structure**– where we dive deeper into how to organize and extend your Express app!

[Memory Boost](2-2MB.md)
